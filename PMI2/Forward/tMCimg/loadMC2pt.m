% LOADMC2PT  Load a .2pt file generated by tMCimg into Matlab
%
% [data, seg] = loadMC2pt( filenm );
%
% data - photon density calculated by tMCimg
% seg  - tissue segmentation used in calculation

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (C) 2004, David Boas, Dana Brooks, Rick Gaudette, 
%                     Tom Gaudette, Eric Miller, Quan Zhang,
%                     Jonathan Stott
%
% This program is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License
% as published by the Free Software Foundation; either version 2
% of the License, or (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function [a, bgs] = loadMC2pt(filenm)

mc = MCConfig(filenm);

% Load the background segmentation

fid = fopen(mc.binFile,'rb');

if (fid < 0)
   error([ 'Error opening file "' mc.binFile '"' ]);
end

[bgs,tt0] = loadbkg(mc, fid);
fclose(fid);

% Load the individual 2pt file(s)

fid = fopen(sprintf('%s.2pt',filenm),'r');

if (fid < 0)
   n = 0;

   fid = fopen(sprintf('%s.2pt.%d',filenm,n),'r');

   if (fid < 0)
      error([ 'Error opening file "' filenm '.2pt"' ]);
   else
      while (fid >= 0)
         atmp = loadfile(mc, fid, bgs, tt0);
         fclose(fid);

         a(:,:,n+1) = atmp;
         clear atmp;

         % Get next file
         n = n + 1;
         fid = fopen(sprintf('%s.2pt.%d',filenm,n),'r');
      end
   end
else
   a = loadfile(mc, fid, bgs, tt0);
   fclose(fid);
end

nx = mc.ximax - mc.ximin + 1;
ny = mc.yimax - mc.yimin + 1;
nz = mc.zimax - mc.zimin + 1;

bgs = reshape(bgs, ny, nx, nz);
a   = reshape(a,   ny, nx, nz, size(a,2), size(a,3));

return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Handle a single, already opened, 2pt file

function[bgs,tt0] = loadbkg(mc, fid)

bg = fread(fid, mc.nxstep*mc.nystep*mc.nzstep, 'uint8');

% Exiting photons recorded in tissue==0 region, generate a mask

t0 = logical(bg == 0);

% Reshape the tables

bg = reshape(bg, [mc.nystep, mc.nxstep, mc.nzstep]);
t0 = reshape(t0, [mc.nystep, mc.nxstep, mc.nzstep]);

bgs = bg(mc.yimin:mc.yimax, mc.ximin:mc.ximax, mc.zimin:mc.zimax);
tt0 = t0(mc.yimin:mc.yimax, mc.ximin:mc.ximax, mc.zimin:mc.zimax);

clear bg t0

nx = mc.ximax - mc.ximin + 1;
ny = mc.yimax - mc.yimin + 1;
nz = mc.zimax - mc.zimin + 1;

bgs = reshape(bgs, nx*ny*nz, 1);
tt0 = reshape(tt0, nx*ny*nz, 1);

return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Handle a single, already opened, 2pt file

function[a] = loadfile(mc, fid, bgs, tt0)

nx = mc.ximax - mc.ximin + 1;
ny = mc.yimax - mc.yimin + 1;
nz = mc.zimax - mc.zimin + 1;

% vv = mc.xstep * mc.ystep * mc.zstep;

% disp('Using TWOPT_T=double'); a = fread(fid,'double');
disp('Using TWOPT_T=float'); a = fread(fid,'float => float');

nt = length(a) / (nx*ny*nz);

if (nt ~= round(nt))
   error(['Size of 2pt file does not match size computed from .inp' ...
	  ' file']);
end

a = reshape(a,nx*ny*nz,nt);

if (nt == 2*mc.nTstep)
   % Complex data, convert from separate real-imaginary storage
   %  to Matlab interal complex storage
   nt = mc.nTstep;
   
   a = double(a(:,1:nt)) + i*double(a(:,nt+1:2*nt));
else
   if (nt ~= mc.nTstep)
      error('Data size and number of time steps do not match');
   end
   
   a = double(a);
end

% Scale out the number of photons
a = a / max(1, mc.NPh);

% Calculate photons passing through in each voxel

b = sum(abs(a),2);

for idx = 1:mc.nTissue       % ??? This isn't a path length ???
  list = find(bgs == idx);
  b(list) = b(list) * mc.tis(idx,3);
end

%% Turn counts into photon density
%
%a = a / vv;

% Total photons exiting medium

list = find(tt0);
am = sum(sum(abs(a(list,:))));

% Total photons absorbed in medium

list = find(~tt0);
ap = sum(b(list));

% Determine scaling constant inside medium

ak = (1-am) / ap;

% Split scaling evenly between the different time slices

ak = ak / nt;

% Rescale the data (turn density into fluence)

a(list,:) = ak * a(list,:);

if (nt > 1)
   a = a / mc.stepT;
else
   a = a / (mc.maxT - mc.minT);
end

return;
