% function[SD,Phi] = repack_tdi(data, hdr, mask, doRight)
%
% data    -> raw (X, Y, nSrc, nTim) array of camera images
% hdr     -> headers corresponding to data
% mask    -> cell array of nSrc (X, Y) fiber masks (logicals)
% doRight -> Right/Left source plate flag

function[SD,Phi] = repack_tdi(Data, Hdr, mask, doRight)

if (isempty(mask))
   error('empty masks not allowed');
end

% Default table sizes, too big is faster than too small

srcl = unique([ Hdr(:).imux ]);

if (isempty(srcl))
   nsrc = 200;
else
   nsrc = length(srcl);
end

timl = unique([ Hdr(:).delay ]);

if (isempty(timl))
   ntim = 100;
else
   ntim = length(timl);
end

wavl = unique([ Hdr(:).lambda ]);

if (any(wavl) == -1)
   % Set a more reasonable (but still impossible) default
   wavl(find(wavl==-1)) = 700;
end

if (isempty(wavl))
   nwav = 10;
else
   nwav = length(wavl);
end

ndet = length(mask);

for k = 1:ndet
   mnz(k) = nnz(mask{k});
end

vdet = find(mnz > 0);

if (isempty(vdet))
   error('All masks are blank');
end

nmes = nsrc * ndet * nwav * ntim;

% Allocate tables using defaults.  Reset counters to zero
srcpos = zeros(nsrc, 3); nsrc = 0;
dlytim = zeros(ntim, 1); ntim = 0;
waveln = zeros(nwav, 1); nwav = 0;

ML     = zeros(nmes + 1, 9);	% +1 to avoid useless extension at end
Phi    = zeros(nmes + 1, 1); nmes = 0;

% Normalize mask to 1

for k = 1:ndet
   mask{k} = mask{k} ./ sum(sum(mask{k}));
end

% Use previous values of hdr and data rather than re-reading.

imeas  = 0;
wh = waitbar(0.0, 'Repacking frames');

if (isempty(get(wh,'XDisplay')))
   % No X display, not a real box
   close(wh);
   wh = [];
end

for nframe = 1:size(Data,3)
   data = Data(:,:,nframe);
   hdr  = Hdr(nframe);

   if (~isempty(wh))
      waitbar(nframe / size(Data,3), wh); drawnow;
   else
      disp(nframe);
   end

   if (nframe == 1)
      srcpos(1,1:2) = [ hdr.muxx hdr.muxy ];
      nsrc = 1;
      iSrc = 1;

      dlytim(1,1) = hdr.delay;
      ntim = 1;
      iDly = 1;

      waveln(1,1) = hdr.lambda;
      nwav = 1;
      iWvl = 1;
   else
      iSrc = find(hdr.imux == srcl);

      if (isempty(iSrc))
         if (~isempty(wh)); close(wh); wh = []; end
         error('non-indexed source positions not supported');
      end

      iDly = find(hdr.delay == timl);

      if (isempty(iDly))
         if (~isempty(wh)); close(wh); wh = []; end
         error('Delay time not found');
      end

      iWvl = find(hdr.lambda == wavl);

      if (isempty(iWvl))
         if (~isempty(wh)); close(wh); wh = []; end
         error('Wavelength not found');
      end
   end

   % Turn frame into measurements

   for iDet = 1:length(mask)
      if (mnz(iDet) == 0)
	 % Mask is all zeros, skip
	 continue;
      end
      
      imeas = imeas + 1;

      if (imeas == size(ML,1))
         % Extending tables one by one is a VERY expensive operation
         disp('Extending measurement tables');
         ML(end+250000,9) = 0;
         Phi(end+250000)  = 0;
      end

      ML(imeas,1:7) = [ iSrc iDet 0 iWvl 0 iDly 1 ];

      % Most of these elements are zero.  Operate only on the non-zero
      % matrix elements (MUCH faster that way).

      mm = find(mask{iDet});
      X = double(data(mm)) .* mask{iDet}(mm);

      % Don't include measurements with saturated CCD pixels

      if (any(X >= 4095))
         Phi(imeas) = -1;               % Saturated
      else
         Phi(imeas) = sum(X);
      end
   end
end

if (~isempty(wh))
    close(wh);
    wh = [];
end

% Reorder the measurement list

ml = find(ML(:,2) > 63);       % Detector indices are modulo-63
ML(ml,2) = ML(ml,2) - 63;

if (doRight)
   srcr = sr;
   ML(1:imeas,1) = srcr(ML(1:imeas,1))';
   clear srcr;
else
   srcl = sl;
   ML(1:imeas,1) = srcl(ML(1:imeas,1))';
   clear srcl;
end

% Copy back tables, trimming down to only those elements I actually used

if (nsrc <= 63)
   [SD.SrcPos,SD.DetPos] = defOptode;
else
   SD.SrcPos      = srcpos(1:nsrc,1:2);
   SD.SrcPos(:,3) = 0;
   SD.DetPos      = zeros(ndet,3);
end

SD.Lambda    = wavl;
SD.SrcAmp    = ones(size(SD.SrcPos,1),length(SD.Lambda));
SD.DetAmp    = ones(size(SD.DetPos,1),length(SD.Lambda));
SD.TimeDelay = timl * 1e-12;
SD.MeasList  = ML(1:imeas,:);

Phi = Phi(1:imeas);

return;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function[SrcPos,DetPos] = defOptode;

SrcPos(1:63,1:3) = [[ 1.0  9.0 0.0 ]; ...
		    [ 2.0  9.0 0.0 ]; ...
		    [ 3.0  9.0 0.0 ]; ...
		    [ 4.0  9.0 0.0 ]; ...
		    [ 5.0  9.0 0.0 ]; ...
		    [ 6.0  9.0 0.0 ]; ...
		    [ 7.0  9.0 0.0 ]; ...

		    [ 1.0  8.0 0.0 ]; ...
		    [ 2.0  8.0 0.0 ]; ...
		    [ 3.0  8.0 0.0 ]; ...
		    [ 4.0  8.0 0.0 ]; ...
		    [ 5.0  8.0 0.0 ]; ...
		    [ 6.0  8.0 0.0 ]; ...
		    [ 7.0  8.0 0.0 ]; ...

		    [ 1.0  7.0 0.0 ]; ...
		    [ 2.0  7.0 0.0 ]; ...
		    [ 3.0  7.0 0.0 ]; ...
		    [ 4.0  7.0 0.0 ]; ...
		    [ 5.0  7.0 0.0 ]; ...
		    [ 6.0  7.0 0.0 ]; ...
		    [ 7.0  7.0 0.0 ]; ...

		    [ 1.0  6.0 0.0 ]; ...
		    [ 2.0  6.0 0.0 ]; ...
		    [ 3.0  6.0 0.0 ]; ...
		    [ 4.0  6.0 0.0 ]; ...
		    [ 5.0  6.0 0.0 ]; ...
		    [ 6.0  6.0 0.0 ]; ...
		    [ 7.0  6.0 0.0 ]; ...

		    [ 1.0  5.0 0.0 ]; ...
		    [ 2.0  5.0 0.0 ]; ...
		    [ 3.0  5.0 0.0 ]; ...
		    [ 4.0  5.0 0.0 ]; ...
		    [ 5.0  5.0 0.0 ]; ...
		    [ 6.0  5.0 0.0 ]; ...
		    [ 7.0  5.0 0.0 ]; ...

		    [ 1.0  4.0 0.0 ]; ...
		    [ 2.0  4.0 0.0 ]; ...
		    [ 3.0  4.0 0.0 ]; ...
		    [ 4.0  4.0 0.0 ]; ...
		    [ 5.0  4.0 0.0 ]; ...
		    [ 6.0  4.0 0.0 ]; ...
		    [ 7.0  4.0 0.0 ]; ...

		    [ 1.0  3.0 0.0 ]; ...
		    [ 2.0  3.0 0.0 ]; ...
		    [ 3.0  3.0 0.0 ]; ...
		    [ 4.0  3.0 0.0 ]; ...
		    [ 5.0  3.0 0.0 ]; ...
		    [ 6.0  3.0 0.0 ]; ...
		    [ 7.0  3.0 0.0 ]; ...

		    [ 1.0  2.0 0.0 ]; ...
		    [ 2.0  2.0 0.0 ]; ...
		    [ 3.0  2.0 0.0 ]; ...
		    [ 4.0  2.0 0.0 ]; ...
		    [ 5.0  2.0 0.0 ]; ...
		    [ 6.0  2.0 0.0 ]; ...
		    [ 7.0  2.0 0.0 ]; ...
		    
		    [ 1.0  1.0 0.0 ]; ...
		    [ 2.0  1.0 0.0 ]; ...
		    [ 3.0  1.0 0.0 ]; ...
		    [ 4.0  1.0 0.0 ]; ...
		    [ 5.0  1.0 0.0 ]; ...
		    [ 6.0  1.0 0.0 ]; ...
		    [ 7.0  1.0 0.0 ] ]; 

DetPos(1:63,1:3) = [[ 1.0 10.5 3.0 ]; ...
		    [ 2.0 10.5 3.0 ]; ...
		    [ 3.0 10.5 3.0 ]; ...
		    [ 4.0 10.5 3.0 ]; ...
		    [ 5.0 10.5 3.0 ]; ...
		    [ 6.0 10.5 3.0 ];
		    [ 7.0 10.5 3.0 ]; ...

		    [ 1.0  9.5 3.0 ]; ...
		    [ 2.0  9.5 3.0 ]; ...
		    [ 3.0  9.5 3.0 ]; ...
		    [ 4.0  9.5 3.0 ]; ...
		    [ 5.0  9.5 3.0 ]; ...
		    [ 6.0  9.5 3.0 ]; ...
		    [ 7.0  9.5 3.0 ]; ...

		    [ 1.0  8.5 3.0 ]; ...
		    [ 2.0  8.5 3.0 ]; ...
		    [ 3.0  8.5 3.0 ]; ...
		    [ 4.0  8.5 3.0 ]; ...
		    [ 5.0  8.5 3.0 ]; ...
		    [ 6.0  8.5 3.0 ]; ...
		    [ 7.0  8.5 3.0 ]; ...

		    [ 1.0  7.5 3.0 ]; ...
		    [ 2.0  7.5 3.0 ]; ...
		    [ 3.0  7.5 3.0 ]; ...
		    [ 4.0  7.5 3.0 ]; ...
		    [ 5.0  7.5 3.0 ]; ...
		    [ 6.0  7.5 3.0 ]; ...
		    [ 7.0  7.5 3.0 ]; ...

		    [ 1.0  6.5 3.0 ]; ...
		    [ 2.0  6.5 3.0 ]; ...
		    [ 3.0  6.5 3.0 ]; ...
		    [ 4.0  6.5 3.0 ]; ...
		    [ 5.0  6.5 3.0 ]; ...
		    [ 6.0  6.5 3.0 ]; ...
		    [ 7.0  6.5 3.0 ]; ...

		    [ 1.0  5.5 3.0 ]; ...
		    [ 2.0  5.5 3.0 ]; ...
		    [ 3.0  5.5 3.0 ]; ...
		    [ 4.0  5.5 3.0 ]; ...
		    [ 5.0  5.5 3.0 ]; ...
		    [ 6.0  5.5 3.0 ]; ...
		    [ 7.0  5.5 3.0 ]; ...

		    [ 1.0  4.5 3.0 ]; ...
		    [ 2.0  4.5 3.0 ]; ...
		    [ 3.0  4.5 3.0 ]; ...
		    [ 4.0  4.5 3.0 ]; ...
		    [ 5.0  4.5 3.0 ]; ...
		    [ 6.0  4.5 3.0 ]; ...
		    [ 7.0  4.5 3.0 ]; ...

		    [ 1.0  3.5 3.0 ]; ...
		    [ 2.0  3.5 3.0 ]; ...
		    [ 3.0  3.5 3.0 ]; ...
		    [ 4.0  3.5 3.0 ]; ...
		    [ 5.0  3.5 3.0 ]; ...
		    [ 6.0  3.5 3.0 ]; ...
		    [ 7.0  3.5 3.0 ]; ...

		    [ 1.0  2.5 3.0 ]; ...
		    [ 2.0  2.5 3.0 ]; ...
		    [ 3.0  2.5 3.0 ]; ...
		    [ 4.0  2.5 3.0 ]; ...
		    [ 5.0  2.5 3.0 ]; ...
		    [ 6.0  2.5 3.0 ]; ...
		    [ 7.0  2.5 3.0 ] ];

return;
